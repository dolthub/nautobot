"""Custom jobs functionality - consolidates and replaces legacy "scripts" and "reports" features."""
import inspect
import json
import logging
import os
import pkgutil
import traceback
import warnings
from collections import OrderedDict

import yaml

from django import forms
from django.conf import settings
from django.core.validators import RegexValidator
from django.db import transaction
from django.utils import timezone
from django.utils.functional import classproperty

from django_rq import job

from .choices import JobResultStatusChoices, LogLevelChoices
from .context_managers import change_logging
from .forms import CustomJobForm

from ipam.formfields import IPAddressFormField, IPNetworkFormField
from ipam.validators import MaxPrefixLengthValidator, MinPrefixLengthValidator, prefix_validator
from utilities.exceptions import AbortTransaction
from utilities.forms import DynamicModelChoiceField, DynamicModelMultipleChoiceField


__all__ = [
    'CustomJob',
    'BooleanVar',
    'ChoiceVar',
    'FileVar',
    'IntegerVar',
    'IPAddressVar',
    'IPAddressWithMaskVar',
    'IPNetworkVar',
    'MultiChoiceVar',
    'MultiObjectVar',
    'ObjectVar',
    'StringVar',
    'TextVar',
]

logger = logging.getLogger(__name__)


class BaseCustomJob:
    """Base model for custom jobs (reports, scripts).

    Users can subclass this directly if they want to provide their own base class for implementing multiple custom jobs
    with shared functionality; if no such sharing is required, use CustomJob class instead.

    For backward compatibility with NetBox, this class has several APIs that can be implemented by the user:

    1. run(self, data, commit) - First method called when invoking a CustomJob, can handle setup and parameter storage.
    2. test_*(self) - Any method matching this pattern will be called next
    3. post_run(self) - Last method called, will be called even in case of an exception during the above methods
    """

    class Meta:
        """
        Metaclass attributes - subclasses can define any or all of the following attributes:

        - name (str)
        - description (str)
        - commit_default (bool)
        """
        pass

    @staticmethod
    def _results_struct():
        return OrderedDict([
            ('success', 0),
            ('info', 0),
            ('warning', 0),
            ('failure', 0),
            ('log', []),
        ])

    def __init__(self):
        self.logger = logging.getLogger(f"netbox.custom_jobs.{self.full_name}")

        self.request = None
        self.active_test = None
        self.failed = False
        self._results = OrderedDict()

        # Grab some info about the job
        self.filename = inspect.getfile(self.__class__)
        self.source = inspect.getsource(self.__class__)

        # Compile test methods and initialize results skeleton
        self.test_methods = []
        self._results["total"] = self._results_struct()
        del self._results["total"]["log"]

        for method_name in dir(self):
            if method_name.startswith('test_') and callable(getattr(self, method_name)):
                self.test_methods.append(method_name)
                self._results[method_name] = self._results_struct()

        # Only initialize results for run and post_run if they're actually implemented
        if self.run.__func__ != BaseCustomJob.run:
            self._results['run'] = self._results_struct()
        if self.post_run.__func__ != BaseCustomJob.post_run:
            self._results['post_run'] = self._results_struct()

    def __str__(self):
        return self.name

    @classmethod
    def module(cls):
        return cls.__module__

    @property
    def class_name(self):
        return self.__class__.__name__

    @classproperty
    def full_name(cls):
        return f"{cls.__module__}.{cls.__name__}"

    @classproperty
    def name(cls):
        return getattr(cls.Meta, 'name', cls.__name__)

    @classproperty
    def description(cls):
        return getattr(cls.Meta, 'description', '')

    @classmethod
    def _get_vars(cls):
        vars = OrderedDict()
        for name, attr in cls.__dict__.items():
            if name not in vars and issubclass(attr.__class__, ScriptVariable):
                vars[name] = attr

        return vars

    @property
    def results(self):
        """
        The results (log messages and final output) generated by this custom job.

        {
            "total": {
                "success": 0,
                "info": 3,
                "warning": 6,
                "failure": 9,
            }
            "run": {
                "success": 0,
                "info": 1,
                "warning": 2,
                "failure": 3,
                "log": [
                    (timestamp, level, object_name, object_url, message),
                    (timestamp, level, object_name, object_url, message),
                    ...
                ],
            },
            "test_function": {
                "success": 0,
                "info": 1,
                "warning": 2,
                "failure": 3,
                "log": [
                    (timestamp, level, object_name, object_url, message),
                    (timestamp, level, object_name, object_url, message),
                    ...
                ],
            },
            "post_run": {
                "success": 0,
                "info": 1,
                "warning": 2,
                "failure": 3,
                "log": [
                    (timestamp, level, object_name, object_url, message),
                    (timestamp, level, object_name, object_url, message),
                    ...
                ],
            },
            "output": "...",
        }
        """
        return self._results

    def as_form(self, data=None, files=None, initial=None):
        """
        Return a Django form suitable for populating the context data required to run this CustomJob.
        """
        fields = {
            name: var.as_field() for name, var in self._get_vars().items()
        }
        FormClass = type('CustomJobForm', (CustomJobForm,), fields)

        form = FormClass(data, files, initial=initial)

        # Set initial "commit" checkbox state based on the Meta parameter
        form.fields['_commit'].initial = getattr(self.Meta, 'commit_default', True)

        return form

    def run(self, data, commit):
        """
        Method invoked when this CustomJob is run, before any "test_*" methods.
        """
        pass

    def post_run(self):
        """
        Method invoked after "run()" and all "test_*" methods.
        """
        pass

    # Logging

    def _log(self, obj, message, level_choice=LogLevelChoices.LOG_DEFAULT, log_level=logging.INFO, status=None):
        """
        Log a message. Do not call this method directly; use one of the log_* wrappers below.
        """
        if level_choice not in LogLevelChoices.as_dict():
            raise Exception(f"Unknown logging level: {level}")

        if status:
            self._results['total'][status] += 1
            self._results[self.active_test][status] += 1
        self._results[self.active_test]['log'].append((
            timezone.now().isoformat(),
            level_choice,
            str(obj) if obj else None,
            obj.get_absolute_url() if hasattr(obj, 'get_absolute_url') else None,
            str(message),
        ))
        if obj and status:
            # Report-style logging
            self.logger.log(log_level, f"{status.upper()} | {obj}: {message}")
        elif message:
            # Script-style logging
            self.logger.log(log_level, message)

    def log(self, message):
        """
        Log a generic message which is not associated with a particular object.
        """
        self._log(None, message, level_choice=LogLevelChoices.LOG_DEFAULT, log_level=logging.INFO)

    def log_debug(self, message):
        """
        Log a debug message which is not associated with a particular object.
        """
        self._log(None, message, level_choice=LogLevelChoices.LOG_DEFAULT, log_level=logging.DEBUG)

    def log_success(self, obj=None, message=None):
        """
        Record a successful test against an object. Logging a message is optional.
        """
        self._log(obj, message, level_choice=LogLevelChoices.LOG_SUCCESS, log_level=logging.INFO, status='success')

    def log_info(self, obj=None, message=None):
        """
        Log an informational message.
        """
        self._log(obj, message, level_choice=LogLevelChoices.LOG_INFO, log_level=logging.INFO, status='info')

    def log_warning(self, obj=None, message=None):
        """
        Log a warning.
        """
        self._log(obj, message, level_choice=LogLevelChoices.LOG_WARNING, log_level=logging.WARNING, status='warning')

    def log_failure(self, obj=None, message=None):
        """
        Log a failure. Calling this method will automatically mark the overall job as failed.
        """
        self._log(obj, message, level_choice=LogLevelChoices.LOG_FAILURE, log_level=logging.ERROR, status='failure')
        self.failed = True

    # Convenience functions

    def load_yaml(self, filename):
        """
        Return data from a YAML file
        """
        # TODO use __file__ here instead?
        file_path = os.path.join(settings.SCRIPTS_ROOT, filename)
        with open(file_path, 'r') as datafile:
            data = yaml.load(datafile)

        return data

    def load_json(self, filename):
        """
        Return data from a JSON file
        """
        # TODO use __file__ here instead?
        file_path = os.path.join(settings.SCRIPTS_ROOT, filename)
        with open(file_path, 'r') as datafile:
            data = json.load(datafile)

        return data


class CustomJob(BaseCustomJob):
    """
    Classes which inherit from this model will appear in the list of available custom jobs.
    """


#
# Script variables
#

class ScriptVariable:
    """
    Base model for script variables
    """
    form_field = forms.CharField

    def __init__(self, label='', description='', default=None, required=True, widget=None):

        # Initialize field attributes
        if not hasattr(self, 'field_attrs'):
            self.field_attrs = {}
        if label:
            self.field_attrs['label'] = label
        if description:
            self.field_attrs['help_text'] = description
        if default:
            self.field_attrs['initial'] = default
        if widget:
            self.field_attrs['widget'] = widget
        self.field_attrs['required'] = required

    def as_field(self):
        """
        Render the variable as a Django form field.
        """
        form_field = self.form_field(**self.field_attrs)
        if not isinstance(form_field.widget, forms.CheckboxInput):
            if form_field.widget.attrs and 'class' in form_field.widget.attrs.keys():
                form_field.widget.attrs['class'] += ' form-control'
            else:
                form_field.widget.attrs['class'] = 'form-control'

        return form_field


class StringVar(ScriptVariable):
    """
    Character string representation. Can enforce minimum/maximum length and/or regex validation.
    """
    def __init__(self, min_length=None, max_length=None, regex=None, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Optional minimum/maximum lengths
        if min_length:
            self.field_attrs['min_length'] = min_length
        if max_length:
            self.field_attrs['max_length'] = max_length

        # Optional regular expression validation
        if regex:
            self.field_attrs['validators'] = [
                RegexValidator(
                    regex=regex,
                    message='Invalid value. Must match regex: {}'.format(regex),
                    code='invalid'
                )
            ]


class TextVar(ScriptVariable):
    """
    Free-form text data. Renders as a <textarea>.
    """
    form_field = forms.CharField

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.field_attrs['widget'] = forms.Textarea


class IntegerVar(ScriptVariable):
    """
    Integer representation. Can enforce minimum/maximum values.
    """
    form_field = forms.IntegerField

    def __init__(self, min_value=None, max_value=None, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Optional minimum/maximum values
        if min_value:
            self.field_attrs['min_value'] = min_value
        if max_value:
            self.field_attrs['max_value'] = max_value


class BooleanVar(ScriptVariable):
    """
    Boolean representation (true/false). Renders as a checkbox.
    """
    form_field = forms.BooleanField

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Boolean fields cannot be required
        self.field_attrs['required'] = False


class ChoiceVar(ScriptVariable):
    """
    Select one of several predefined static choices, passed as a list of two-tuples. Example:

        color = ChoiceVar(
            choices=(
                ('#ff0000', 'Red'),
                ('#00ff00', 'Green'),
                ('#0000ff', 'Blue')
            )
        )
    """
    form_field = forms.ChoiceField

    def __init__(self, choices, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Set field choices
        self.field_attrs['choices'] = choices


class MultiChoiceVar(ChoiceVar):
    """
    Like ChoiceVar, but allows for the selection of multiple choices.
    """
    form_field = forms.MultipleChoiceField


class ObjectVar(ScriptVariable):
    """
    A single object within NetBox.

    :param model: The NetBox model being referenced
    :param display_field: The attribute of the returned object to display in the selection list (default: 'name')
    :param query_params: A dictionary of additional query parameters to attach when making REST API requests (optional)
    :param null_option: The label to use as a "null" selection option (optional)
    """
    form_field = DynamicModelChoiceField

    def __init__(self, model=None, queryset=None, display_field='name', query_params=None, null_option=None, *args,
                 **kwargs):
        super().__init__(*args, **kwargs)

        # Set the form field's queryset. Support backward compatibility for the "queryset" argument for now.
        if model is not None:
            self.field_attrs['queryset'] = model.objects.all()
        elif queryset is not None:
            warnings.warn(
                f'{self}: Specifying a queryset for ObjectVar is no longer supported. Please use "model" instead.'
            )
            self.field_attrs['queryset'] = queryset
        else:
            raise TypeError('ObjectVar must specify a model')

        self.field_attrs.update({
            'display_field': display_field,
            'query_params': query_params,
            'null_option': null_option,
        })


class MultiObjectVar(ObjectVar):
    """
    Like ObjectVar, but can represent one or more objects.
    """
    form_field = DynamicModelMultipleChoiceField


class FileVar(ScriptVariable):
    """
    An uploaded file.
    """
    form_field = forms.FileField


class IPAddressVar(ScriptVariable):
    """
    An IPv4 or IPv6 address without a mask.
    """
    form_field = IPAddressFormField


class IPAddressWithMaskVar(ScriptVariable):
    """
    An IPv4 or IPv6 address with a mask.
    """
    form_field = IPNetworkFormField


class IPNetworkVar(ScriptVariable):
    """
    An IPv4 or IPv6 prefix.
    """
    form_field = IPNetworkFormField

    def __init__(self, min_prefix_length=None, max_prefix_length=None, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Set prefix validator and optional minimum/maximum prefix lengths
        self.field_attrs['validators'] = [prefix_validator]
        if min_prefix_length is not None:
            self.field_attrs['validators'].append(
                MinPrefixLengthValidator(min_prefix_length)
            )
        if max_prefix_length is not None:
            self.field_attrs['validators'].append(
                MaxPrefixLengthValidator(max_prefix_length)
            )


def is_custom_job(obj):
    """
    Returns True if the given object is a CustomJob subclass.
    """
    from .scripts import Script, BaseScript
    from .reports import Report

    try:
        return issubclass(obj, CustomJob) and obj not in [Script, BaseScript, Report]
    except TypeError:
        return False


def is_variable(obj):
    """
    Returns True if the object is a ScriptVariable instance.
    """
    return isinstance(obj, ScriptVariable)


def get_custom_jobs():
    """
    Compile a dictionary of all custom jobs available across all modules in the jobs path(s).

    Returns an OrderedDict:

    {
        <module_name>: {
            "name": <human-readable name>,
            "jobs": {
               <job_name>: <job_class>,
               <job_name>: <job_class>,
               ...
            },
        },
        <module_name>: { ... },
        ...
    }
    """
    custom_jobs = OrderedDict()

    paths = []
    if settings.CUSTOM_JOBS_ROOT:
        paths.append(settings.CUSTOM_JOBS_ROOT)
    if settings.SCRIPTS_ROOT and settings.SCRIPTS_ROOT not in paths:
        logger.warning("settings.SCRIPTS_ROOT is deprecated; use settings.CUSTOM_JOBS_ROOT instead")
        paths.append(settings.SCRIPTS_ROOT)
    if settings.REPORTS_ROOT and settings.REPORTS_ROOT not in paths:
        logger.warning("settings.REPORTS_ROOT is deprecated; use settings.CUSTOM_JOBS_ROOT instead")
        paths.append(settings.REPORTS_ROOT)
    # TODO: add plugin and Git job paths to "paths" as well

    for importer, module_name, _ in pkgutil.iter_modules(paths):
        module = importer.find_module(module_name).load_module(module_name)
        human_readable_name = module.name if hasattr(module, "name") else module_name
        module_jobs = {"name": human_readable_name, "jobs": OrderedDict()}
        for name, cls in inspect.getmembers(module, is_custom_job):
            module_jobs["jobs"][name] = cls
        if module_jobs["jobs"]:
            custom_jobs[module_name] = module_jobs

    return custom_jobs


def get_custom_job(module_name, job_name):
    """
    Return a specific custom job from within a specific module, or None.
    """
    custom_jobs = get_custom_jobs()
    module_entry = custom_jobs.get(module_name)
    if module_entry:
        return module_entry["jobs"].get(job_name)
    return None


@job('default')
def run_custom_job(data, request, job_result, commit=True, *args, **kwargs):
    """
    Helper function to call the "run()", "test_*()", and "post_run" methods on a CustomJob.

    This gets around the inability to pickle an instance method for queueing into the background processor.
    """
    module_name, job_name = job_result.name.split('.', 1)
    custom_job = get_custom_job(module_name, job_name)()

    # TODO: validate that all args required by this job are set in the data or else log helpful errors?

    logger = logging.getLogger(f"netbox.custom_jobs.{module_name}.{job_name}")
    logger.info(f"Running custom job (commit={commit})")

    job_result.status = JobResultStatusChoices.STATUS_RUNNING
    job_result.save()

    # Add any files to the form data
    if request:
        files = request.FILES
        for field_name, fileobj in files.items():
            data[field_name] = fileobj

    # Add the current request as a property of the job
    custom_job.request = request

    def _run_custom_job():
        """
        Core custom job execution task.

        We capture this within a subfunction to allow for conditionally wrapping it with the change_logging
        context manager (which is only relevant if commit == True).
        """
        custom_job.results["output"] = ""
        try:
            with transaction.atomic():
                # Script-like behavior
                custom_job.active_test = "run"
                output = custom_job.run(data=data, commit=commit)
                if output:
                    custom_job.results["output"] += "\n" + str(output)

                # Report-like behavior
                for method_name in custom_job.test_methods:
                    custom_job.active_test = method_name
                    output = getattr(custom_job, method_name)()
                    if output:
                        custom_job.results["output"] += "\n" + str(output)

                if custom_job.failed:
                    custom_job.logger.warning("Custom job failed")
                    job_result.set_status(JobResultStatusChoices.STATUS_FAILED)
                else:
                    custom_job.logger.info("Custom job completed successfully")
                    job_result.set_status(JobResultStatusChoices.STATUS_COMPLETED)

                if not commit:
                    raise AbortTransaction()

        except AbortTransaction:
            custom_job.log_info(message="Database changes have been reverted automatically.")

        except Exception as exc:
            stacktrace = traceback.format_exc()
            custom_job.log_failure(
                message=f"An exception occurred: `{type(exc).__name__}: {exc}`\n```\n{stacktrace}\n```"
            )
            custom_job.log_info(message="Database changes have been reverted due to error.")
            logger.error(f"Exception raised during custom job execution: {exc}")
            job_result.set_status(JobResultStatusChoices.STATUS_ERRORED)

        finally:
            job_result.data = custom_job.results
            job_result.save()

        # Perform any post-run tasks
        custom_job.active_test = 'post_run'
        output = custom_job.post_run()
        if output:
            custom_job.results["output"] += "\n" + str(output)

        job_result.completed = timezone.now()
        job_result.save()

        logger.info(f"Custom job completed in {job_result.duration}")

    # Execute the custom job. If commit == True, wrap it with the change_logging context manager to ensure we
    # process change logs, webhooks, etc.
    if commit:
        with change_logging(request):
            _run_custom_job()
    else:
        _run_custom_job()
